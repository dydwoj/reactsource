<< React >>
    - 개발환경

    1) Node.js 설치 (패키지 관리도구 npm 이 설치됨)
        => 프로젝트마다 패키지 설치 : 터미널창 => npm i 패키지명
            
    - 선택사항 (yarn 설치)
        => 패키지 관리도구 => npm 보다 효율적이고 빠름
        1. npm i --global yarn
        2. yarn --version

        * 패키지 설치 명령어
            yarn add 패키지명
            
            - 설치 패키지
                1. tailwindcss @tailwindcss/vite

    2) extension
        1. reactjs code snippets - charalampos karypidis
        2. Tailwind CSS IntelliSense - Tailwind Labs
        3. Material Icon Theme - Philipp Kief (파일 색상 테마)
            
        - 엣지 설치
            addons 검색
                => 마소페이지 addons 들어가기
                => react developer tools 다운로드

    3) 환경설정 (vscode)
        1. emmet 검색
            =>  Include Languages 
                item : javascript
                value : javascriptreact
        2. Default Formatter : Prettier

    4) react 프로그램 생성

        1. npx create-react-app 앱이름  (전통적인 방법)
            => CRA 방식으로 프로그램 생성

        2. vite 환경에서 react 프로그램 생성

        - 생성 명령어 순서
                
            * cd .. 해당 프로그램에서 나오기

            - 선택하면서 하기
                1. yarn create vite
                2. 이름 설정
                3. react
                4. javascript
                5. 순서대로 치기
                    cd begin1
                    => yarn
                    => yarn dev
                        * o : 브라우저 오픈
                        * q : 빠져나오기

            - 한번에 실행하기
                yarn create vite 앱이름 --template react
                    => cd begin1
                    => yarn
                    => yarn dev
        
    5) 프로젝트 구조

        1. package.json : Node 기반 프로젝트는 가지고 있음 == porm.xml 과 같음
            - dependencies : 사용자가 필요한 것
            - devDependencies : 개발자가 필요한 것

        2. eslint.config.js : eslint 환경설정 파일
            => eslint : 자바스크립트 문법 검사
            * config : 환경설정을 파일임을 의미

        3. vite.config.js : vite 환경설정 파일

    - 명령어
        
        1) yarn dev
            => 작성하는 코드 실시간으로 확인하며 페이지 개발하게 하는 명령어
            press r + enter : restart the server
            press u + enter : show server url   
            press o + enter : open in browser
            press c + enter : clear console
            press q + enter : quit

        2) yarn build
            => 개발된 코드들을 하나로 합쳐서 서비스할 수 있는 상태로 만들어 줌
            => dist 폴더 생성 : 배포용 파일
            => src 폴더 안 jsx 파일들을 번들러를 이용해 최적화 작업을 하게 됨
                * 번들러 : 묶어주는 개념

        3) yarn preview
            => 미리보기 (서버에 배포된 후 실행결과 보기)

    < jsx 문법 >
        => 자바스크립트 확장 문법
        => 브라우저에서 실행되기 전에 코드가 번들링 되는 과정에서 바벨을 사용하여 일반 자브스크립트 코드로 변환됨
            * 번들러
                => 여러개의 모듈로 개발한 것들을 묶어서 서비스하게 해줌
                    도구 : 웹팩 => 이외에도 다른 도구들도 있음
            * 바벨 : 자바스크립트 문법으로 변환하게 해줌

        * rsc : 자동 완성 (html : ! 처럼)
        * className : html의 class 와 동일 === class=""
        * maxlength == maxLength
        * readonly == readOnly

        - {} 사용
            => 태그가 여러개가 있을 때는 꼭 묶어줘야 함 => 하나의 태그로 만들어서 보낸다
            => return 안에서 자바스크립트 코드를 사용하고 싶을때도 사용
            => 함수를 사용하고 싶으면 {}(괄호) 안에서 사용해야 함
            => 변수에 하나의 값만 던지는게 아닌 함수 그 자체를 던질 수 있음
                ex) name={()=>()} 로 {} 안에 함수 선언 가능

        - if 문 대신에 조건부 연산자를 많이 사용
            1) 조건 ? 참 : 거짓 : 일반적인 조건부 연산자

            2) 조건 && 참 : 조건부 렌더링 (참인 경우에만 작동)
                => 만약 else 가 필요하지 않는 경우 사용

            3) 값1 ?? 값2 : null or undefined 인 경우 뒤에 오는 값 반환
                => ?? : 비어있는 문자열에는 처리 X

            4) 값1 || 값2 : null or undefined 인 경우 뒤에 오는 값 반환
                => 비어 있는 문자열 처리 O

            * 참 / 거짓
                참 : 0 제외 숫자, '문자', [], {}
                거짓 : 0, '', null, undefined, NaN

        - map (foreach 같은 함수)
            참고 : react/MyComponent
            => 사용시 배열로 나옴
                => 함수를 실행한 결과가 새로운 배열로 리턴

            * map(() => {})
                => 결과값에 {} 치는 순간 return 을 사용해야 한다
                but. {} 없으면 return 사용 X

            -메서드
                1. join() : 배열 사이에 추가할 수 있음
                2. filter() : true/false 값이 나오는 조건을 주면 조건에 맞는 값 출력

    < CSS >
        참고 : MyStyle

        - 스타일 적용
            1) ~~.css : import 사용
            2) jsx 안에서 스타일 선언
                => 객체 선언 해서 태그 안에 객체명으로 style 선언 가능
            3) 인라인 방식 : 태그 안에 직접 사용
                ex) <div style={{ color: "red", fontSize: "25px" }}>홍길동</div>
            4) CSS module
                => 만드는 법 : 이름.module.css
                => component마다 스타일 클래스명이 중첩되는 것을 방지해 줌
                => 들여올 때마다 개별적인 임의의 이름을 부여하기 때문
        

        - 단독태그
            ex) br 등...
            => js 에서는 단독태그 존재 X => 무조건 닫아야 한다

    < component > : 대문자로 생성 (java 처럼)
        참고 : components
        - 예전엔 클래스로 구현
        - 요즘은 함수로 구현
        - 각자 따로 개발하고 하나로 모아서 내보내야 함
            => 내보내는게 중요함!!
        
        * 부모가 값을 자식한테 받는 경우 X !! => 부모의 값을 자식이 받는 경우만 존재

        - 작성
            => 쪼개서 구현 => jsx 라고 부름

        - 공유
            참고 : MyApp, MyButton
            => 공유하려면 부모가 값을 가지고 있어야 함
            => props 개념을 사용

            - 작성
                1. 부모 : 값과 함수를 가지고 있어야 함
                2. import 한 자식에게 값에대한 값을 던짐
                3. 자식 : 값을 받아서 추출
        
    < props >
        참고 : 엣지/f12/components 확인, card, product 확인
        => key=value 형태
        => properties 줄임말
        => 컴포넌트들 사이에서 데이터를 전달시 사용
            but. 부모 -> 자식 에게 데이터를 전달하는 경우 사용
        => 단순히 생각해서 상속의 느낌임
            => 코드의 실행 순서에 따라 위치가 정해짐
        
        - 함수 던지기
            부모 -> 자식한테 key="value" 형태로 던질 수 있음
                ex) 부모 : <자식명 key="value" />
                                => import 하는 구문
                    자식 : const MyComponent = ({ key값, key값 }) => {}
                
                * key / value 형태로 여러개 보낼 수 있음
                    => 그만큼 반복을 함
                * 넘겨주는 모든 값을 자식이 사용해야 하는 것은 아님
                    => 쓰고 싶은 만큼만 사용하면 됨

    < children >
        참고 : CardLayout, ParentCardLayout
        => component 태그 사이의 내용 보여주기
        => 외부에 레이아웃 컴포넌트를 구성한 뒤 내용을 자유롭게 채울 때 사용
            ex) 부모 jsx : <App name="홍길동">
                           <App name="홍길동">내용</App>

    < state >
        참고 : Counter, InputSample, InputMultipleSample
            => 리액트는 가상 DOM 형성
               이벤트 발생시 가상 DOM 에 변화를 줌
               기존 DOM 의 변경된 부분과 가상 DOM 의 값이 달라지면 기존 DOM 제거 후 가상 DOM 을 업데이트
               지금까지의 DOM 은 달라진 부분만 변경 했음 => axios 사용 등...
               리액트는 달라지면 전체를 변화시켜서 처음부터 저장하는 개념
                    => 처리 속도가 일부분만 교체 보다는 새로 전부 업데이트가 빠르다

        - 함수

            < use~~~ > : hook 이라고 부름

                - Rerendering (재렌더링)
                    부모가 렌더링이 되면 자식도 같이 렌더링이 됨
                    but. 자식이 재렌더링이 된다고 부모한테 영향 X (역으로 영향을 주지는 않음)


                - useState() : 새로운 UI 반영
                    => 동적으로 변화하는 변수의 상태를 확인 함
                    => 컨포넌트 내부에서 변경될 수 있는 값으로 값이 변경될 때마다 페이지가 렌더링(rerendering) 됨
                    => useState 가 관리하는 변수가 업데이트 된다면 가상 DOM 을 업데이트 하는 개념
                        => 기존의 다른 변수들은 새로고침이 됨
                    
                    - 사용법
                        => 변수명, 함수명
                            => ex) const [변수명, 함수명] = useState();
                            => ex2) const [count, setCount] = useState(0);
                                => 숫자일시, 0 으로
                                => count 값 변화가 일어나면 웹페이지 리렌더링(== 새로고침)
                            => ex3) const [text, setText] = useState("")
                                => 문자일시, 빈 문자열로
                    
                    - 여러개를 묶어서 사용하기
                        useState({
                            key1: value1
                            key2: value2
                        })
                            =>
                
                    - useRef() : useState() 발생시, 리렌더링 될 때 렌더링과 관계없이 useRef() 값을 유지함
                        참고 : begin/CounterRef, InputRef
                        => rerendering 이 되어도 본인이 가지고 있는 값을 그대로 가지고 있음
                           컨포넌트가 특정 정보를 기억해야 할 필요가 있을 때 사용
                           스크롤바 위치, 포커스 설정, 특정 요소의 크기 가져오기 같은 DOM 선택

                        * useRef 값이 변경된다면 변경된 그 값 유지

                        - 기억할 요소 선택
                            const inputText = useRef(null);

                            const handleFocus = (e) => {
                                inputText.current.focus();
                            };
                                => 기억할 요소 선택 : current 를 통해 접근

                            return <input type="text" ref={inputText} />
                                => 기억할 요소에 ref="" 속성 사용


        - 동적으로 변화시키는 속성
            1) onClick : 클릭시
            2) onChange : 변화시

    